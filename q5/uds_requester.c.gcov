        -:    0:Source:uds_requester.c
        -:    1:/**
        -:    2: * uds_requester.c - Q5
        -:    3: *
        -:    4: * Client with UDS support (both stream and datagram)
        -:    5: * Enhanced with proper server response handling and no default fallbacks
        -:    6: * 
        -:    7: * Usage:
        -:    8: *   ./uds_requester -h <hostname/IP> -p <tcp_port> [-u <udp_port>]
        -:    9: *   ./uds_requester -f <UDS_stream_path> [-d <UDS_datagram_path>]
        -:   10: */
        -:   11:
        -:   12:#include <stdio.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <string.h>
        -:   15:#include <unistd.h>
        -:   16:#include <getopt.h>
        -:   17:#include <sys/types.h>
        -:   18:#include <sys/socket.h>
        -:   19:#include <sys/un.h>
        -:   20:#include <netinet/in.h>
        -:   21:#include <arpa/inet.h>
        -:   22:#include <errno.h>
        -:   23:#include <netdb.h>
        -:   24:
        -:   25:#define BUFFER_SIZE 256
        -:   26:#define MAX_ATOMS 1000000000000000000ULL
        -:   27:
        5:   28:void show_usage(const char *program_name) {
        5:   29:    printf("Usage: %s [network options] [uds options]\n\n", program_name);
        5:   30:    printf("Network options:\n");
        5:   31:    printf("  -h, --host HOST         Server hostname or IP address\n");
        5:   32:    printf("  -p, --port PORT         TCP port\n");
        5:   33:    printf("  -u, --udp-port PORT     UDP port (enables molecule requests)\n\n");
        5:   34:    printf("UDS options:\n");
        5:   35:    printf("  -f, --file PATH         UDS stream socket file path\n");
        5:   36:    printf("  -d, --datagram PATH     UDS datagram socket file path (enables molecule requests)\n");
        5:   37:    printf("\nExamples:\n");
        5:   38:    printf("  %s -h 127.0.0.1 -p 12345 -u 12346\n", program_name);
        5:   39:    printf("  %s -f /tmp/stream.sock -d /tmp/datagram.sock\n", program_name);
        5:   40:    printf("  %s -f /tmp/stream.sock\n", program_name);
        5:   41:}
        -:   42:
       35:   43:void show_main_menu(int molecule_enabled) {
       35:   44:    printf("\n=== MOLECULE REQUESTER MENU ===\n");
       35:   45:    printf("1. Add atoms\n");
       35:   46:    if (molecule_enabled) printf("2. Request molecule delivery\n");
       35:   47:    printf("3. Quit\n");
       35:   48:    printf("Your choice: ");
       35:   49:}
        -:   50:
       34:   51:void show_atom_menu() {
       34:   52:    printf("\n--- ADD ATOMS ---\n");
       34:   53:    printf("1. CARBON\n2. OXYGEN\n3. HYDROGEN\n4. Back\nYour choice: ");
       34:   54:}
        -:   55:
       23:   56:void show_molecule_menu() {
       23:   57:    printf("\n--- REQUEST MOLECULE ---\n");
       23:   58:    printf("1. WATER\n2. CARBON DIOXIDE\n3. ALCOHOL\n4. GLUCOSE\n5. Back\nYour choice: ");
       23:   59:}
        -:   60:
       36:   61:int read_unsigned_long_long(unsigned long long *result) {
        -:   62:    char input[BUFFER_SIZE];
      36*:   63:    if (!fgets(input, sizeof(input), stdin)) return 0;
        -:   64:    char *endptr;
       36:   65:    errno = 0;
       36:   66:    unsigned long long value = strtoull(input, &endptr, 10);
      36*:   67:    if (errno != 0 || endptr == input || (*endptr != '\n' && *endptr != '\0')) return 0;
       34:   68:    *result = value;
       34:   69:    return 1;
        -:   70:}
        -:   71:
       14:   72:int hostname_to_ip(const char *hostname, char *ip) {
        -:   73:    struct hostent *he;
        -:   74:    struct in_addr addr;
        -:   75:    
       14:   76:    if (inet_aton(hostname, &addr)) {
        5:   77:        strcpy(ip, hostname);
        5:   78:        return 0;
        -:   79:    }
        -:   80:    
        9:   81:    he = gethostbyname(hostname);
        9:   82:    if (he == NULL) {
    #####:   83:        return -1;
        -:   84:    }
        -:   85:    
        9:   86:    strcpy(ip, inet_ntoa(*((struct in_addr*)he->h_addr)));
        9:   87:    return 0;
        -:   88:}
        -:   89:
       20:   90:int is_shutdown_message(const char *msg) {
       40:   91:    return (strstr(msg, "shutting down") != NULL || 
      40*:   92:            strstr(msg, "shutdown") != NULL ||
       20:   93:            strstr(msg, "closing") != NULL);
        -:   94:}
        -:   95:
       24:   96:int main(int argc, char *argv[]) {
       24:   97:    char *server_host = NULL;
       24:   98:    int tcp_port = -1, udp_port = -1;
       24:   99:    char *uds_stream_path = NULL, *uds_datagram_path = NULL;
       24:  100:    int use_uds = 0, use_network = 0;
        -:  101:    
        -:  102:    int opt;
       79:  103:    while ((opt = getopt(argc, argv, "h:p:u:f:d:")) != -1) {
       60:  104:        switch (opt) {
       18:  105:            case 'h':
       18:  106:                server_host = optarg;
       18:  107:                use_network = 1;
       18:  108:                break;
       19:  109:            case 'p':
       19:  110:                tcp_port = atoi(optarg);
       19:  111:                if (tcp_port <= 0 || tcp_port > 65535) {
        1:  112:                    fprintf(stderr, "Error: Invalid TCP port: %s\n", optarg);
        1:  113:                    exit(EXIT_FAILURE);
        -:  114:                }
       18:  115:                use_network = 1;
       18:  116:                break;
       18:  117:            case 'u':
       18:  118:                udp_port = atoi(optarg);
       18:  119:                if (udp_port <= 0 || udp_port > 65535) {
        4:  120:                    fprintf(stderr, "Error: Invalid UDP port: %s\n", optarg);
        4:  121:                    exit(EXIT_FAILURE);
        -:  122:                }
       14:  123:                use_network = 1;
       14:  124:                break;
        2:  125:            case 'f':
        2:  126:                uds_stream_path = optarg;
        2:  127:                use_uds = 1;
        2:  128:                break;
        3:  129:            case 'd':
        3:  130:                uds_datagram_path = optarg;
        3:  131:                use_uds = 1;
        3:  132:                break;
    #####:  133:            default:
    #####:  134:                show_usage(argv[0]);
    #####:  135:                exit(EXIT_FAILURE);
        -:  136:        }
        -:  137:    }
        -:  138:    
        -:  139:    // Check for conflicting arguments
       19:  140:    if (use_uds && use_network) {
        1:  141:        fprintf(stderr, "Error: Cannot use both UDS socket files and network address/port\n");
        1:  142:        exit(EXIT_FAILURE);
        -:  143:    }
        -:  144:    
       18:  145:    if (use_network) {
       14:  146:        if (!server_host || tcp_port == -1) {
        3:  147:            fprintf(stderr, "Error: Server hostname/IP and TCP port are required for network connection\n");
        3:  148:            show_usage(argv[0]);
        3:  149:            exit(EXIT_FAILURE);
        -:  150:        }
       11:  151:        if (udp_port != -1 && tcp_port == udp_port) {
        1:  152:            fprintf(stderr, "Error: TCP and UDP ports must be different\n");
        1:  153:            exit(EXIT_FAILURE);
        -:  154:        }
        4:  155:    } else if (use_uds) {
        2:  156:        if (!uds_stream_path) {
    #####:  157:            fprintf(stderr, "Error: UDS stream socket file path is required (-f option)\n");
    #####:  158:            show_usage(argv[0]);
    #####:  159:            exit(EXIT_FAILURE);
        -:  160:        }
        -:  161:    } else {
        2:  162:        fprintf(stderr, "Error: Must specify either network connection or UDS connection\n");
        2:  163:        show_usage(argv[0]);
        2:  164:        exit(EXIT_FAILURE);
        -:  165:    }
        -:  166:    
        -:  167:    // Setup connections
       12:  168:    int stream_fd = -1, datagram_fd = -1;
       12:  169:    int molecule_enabled = 0;
        -:  170:    
       12:  171:    if (use_network) {
        -:  172:        // TCP connection using getaddrinfo (as required by PDF)
        -:  173:        struct addrinfo hints, *servinfo, *p;
        -:  174:        int rv;
        -:  175:        
       10:  176:        memset(&hints, 0, sizeof hints);
       10:  177:        hints.ai_family = AF_INET;
       10:  178:        hints.ai_socktype = SOCK_STREAM;
        -:  179:        
        -:  180:        char port_str[6];
       10:  181:        snprintf(port_str, sizeof(port_str), "%d", tcp_port);
        -:  182:        
       10:  183:        if ((rv = getaddrinfo(server_host, port_str, &hints, &servinfo)) != 0) {
        1:  184:            fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        1:  185:            exit(EXIT_FAILURE);
        -:  186:        }
        -:  187:        
        -:  188:        // Try to connect
       9*:  189:        for(p = servinfo; p != NULL; p = p->ai_next) {
       9*:  190:            if ((stream_fd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
    #####:  191:                perror("socket");
    #####:  192:                continue;
        -:  193:            }
        -:  194:            
       9*:  195:            if (connect(stream_fd, p->ai_addr, p->ai_addrlen) == -1) {
    #####:  196:                close(stream_fd);
    #####:  197:                perror("connect");
    #####:  198:                continue;
        -:  199:            }
        -:  200:            
        9:  201:            break;
        -:  202:        }
        -:  203:        
        9:  204:        if (p == NULL) {
    #####:  205:            fprintf(stderr, "Failed to connect\n");
    #####:  206:            freeaddrinfo(servinfo);
    #####:  207:            exit(EXIT_FAILURE);
        -:  208:        }
        -:  209:        
        -:  210:        char server_ip[INET_ADDRSTRLEN];
        9:  211:        struct sockaddr_in *addr = (struct sockaddr_in *)p->ai_addr;
        9:  212:        inet_ntop(AF_INET, &(addr->sin_addr), server_ip, INET_ADDRSTRLEN);
        -:  213:        
        9:  214:        freeaddrinfo(servinfo);
        -:  215:        
        9:  216:        printf("Connected to TCP server at %s:%d", server_ip, tcp_port);
        -:  217:        
        -:  218:        // UDP connection (optional)
        9:  219:        if (udp_port != -1) {
        9:  220:            datagram_fd = socket(AF_INET, SOCK_DGRAM, 0);
        9:  221:            if (datagram_fd < 0) {
    #####:  222:                perror("UDP socket creation failed");
    #####:  223:                close(stream_fd);
    #####:  224:                exit(EXIT_FAILURE);
        -:  225:            }
        9:  226:            molecule_enabled = 1;
        9:  227:            printf(", UDP:%d", udp_port);
        -:  228:        }
        9:  229:        printf("\n");
        -:  230:        
        -:  231:    } else {
        -:  232:        // UDS stream connection
        2:  233:        stream_fd = socket(AF_UNIX, SOCK_STREAM, 0);
        2:  234:        if (stream_fd < 0) {
    #####:  235:            perror("UDS stream socket creation failed");
    #####:  236:            exit(EXIT_FAILURE);
        -:  237:        }
        -:  238:        
        -:  239:        struct sockaddr_un stream_addr;
        2:  240:        memset(&stream_addr, 0, sizeof(stream_addr));
        2:  241:        stream_addr.sun_family = AF_UNIX;
        2:  242:        strncpy(stream_addr.sun_path, uds_stream_path, sizeof(stream_addr.sun_path) - 1);
        -:  243:        
        2:  244:        if (connect(stream_fd, (struct sockaddr*)&stream_addr, sizeof(stream_addr)) < 0) {
    #####:  245:            perror("UDS stream connection failed");
    #####:  246:            close(stream_fd);
    #####:  247:            exit(EXIT_FAILURE);
        -:  248:        }
        -:  249:        
        2:  250:        printf("Connected to UDS stream server at %s", uds_stream_path);
        -:  251:        
        -:  252:        // UDS datagram connection (optional)
        2:  253:        if (uds_datagram_path) {
        2:  254:            datagram_fd = socket(AF_UNIX, SOCK_DGRAM, 0);
        2:  255:            if (datagram_fd < 0) {
    #####:  256:                perror("UDS datagram socket creation failed");
    #####:  257:                close(stream_fd);
    #####:  258:                exit(EXIT_FAILURE);
        -:  259:            }
        2:  260:            molecule_enabled = 1;
        2:  261:            printf(", datagram:%s", uds_datagram_path);
        -:  262:        }
        2:  263:        printf("\n");
        -:  264:    }
        -:  265:
       11:  266:    int running = 1;
       11:  267:    int server_connected = 1;
        -:  268:    char buffer[BUFFER_SIZE], recv_buffer[BUFFER_SIZE];
        -:  269:    
       46:  270:    while (running && server_connected) {
       35:  271:        show_main_menu(molecule_enabled);
        -:  272:        int choice;
      35*:  273:        if (scanf("%d", &choice) != 1) { 
    #####:  274:            while (getchar() != '\n'); 
    #####:  275:            continue; 
        -:  276:        }
       35:  277:        while (getchar() != '\n');
        -:  278:
       35:  279:        if (choice == 1) {
        -:  280:            // Add atoms (via stream connection)
        -:  281:            int atom_choice;
       34:  282:            while (server_connected) {
       34:  283:                show_atom_menu();
      34*:  284:                if (scanf("%d", &atom_choice) != 1) { 
    #####:  285:                    while (getchar() != '\n'); 
    #####:  286:                    continue; 
        -:  287:                }
       34:  288:                while (getchar() != '\n');
        -:  289:
       34:  290:                if (atom_choice == 4) break;
        -:  291:
        -:  292:                const char *atom;
      20*:  293:                switch (atom_choice) {
       10:  294:                    case 1: atom = "CARBON"; break;
        5:  295:                    case 2: atom = "OXYGEN"; break;
        5:  296:                    case 3: atom = "HYDROGEN"; break;
    #####:  297:                    default: printf("Invalid atom choice.\n"); continue;
        -:  298:                }
        -:  299:
       20:  300:                printf("Amount to add (max %llu): ", MAX_ATOMS);
        -:  301:                unsigned long long amount;
      20*:  302:                if (!read_unsigned_long_long(&amount) || amount > MAX_ATOMS) {
    #####:  303:                    printf("Invalid number.\n"); 
    #####:  304:                    continue;
        -:  305:                }
        -:  306:
       20:  307:                snprintf(buffer, sizeof(buffer), "ADD %s %llu\n", atom, amount);
       20:  308:                if (send(stream_fd, buffer, strlen(buffer), 0) == -1) {
    #####:  309:                    perror("Stream send failed");
    #####:  310:                    server_connected = 0;
    #####:  311:                    break;
        -:  312:                }
        -:  313:                
        -:  314:                // Receive and display server response
       20:  315:                int n = recv(stream_fd, recv_buffer, sizeof(recv_buffer) - 1, 0);
       20:  316:                if (n <= 0) {
    #####:  317:                    if (n == 0) {
    #####:  318:                        printf("Server disconnected.\n");
        -:  319:                    } else {
    #####:  320:                        perror("Stream receive failed");
        -:  321:                    }
    #####:  322:                    server_connected = 0;
    #####:  323:                    break;
        -:  324:                } else {
       20:  325:                    recv_buffer[n] = '\0';
       20:  326:                    printf("Server: %s", recv_buffer);
        -:  327:                    
       20:  328:                    if (is_shutdown_message(recv_buffer)) {
    #####:  329:                        printf("Server is shutting down. Disconnecting...\n");
    #####:  330:                        server_connected = 0;
    #####:  331:                        break;
        -:  332:                    }
        -:  333:                    
        -:  334:                    // Try to receive additional messages (like status update)
        -:  335:                    fd_set read_fds;
        -:  336:                    struct timeval timeout;
      340:  337:                    FD_ZERO(&read_fds);
       20:  338:                    FD_SET(stream_fd, &read_fds);
       20:  339:                    timeout.tv_sec = 0;
       20:  340:                    timeout.tv_usec = 100000; // 100ms timeout
        -:  341:                    
       20:  342:                    if (select(stream_fd + 1, &read_fds, NULL, NULL, &timeout) > 0) {
        7:  343:                        n = recv(stream_fd, recv_buffer, sizeof(recv_buffer) - 1, 0);
        7:  344:                        if (n > 0) {
        7:  345:                            recv_buffer[n] = '\0';
        7:  346:                            printf("Server: %s", recv_buffer);
        -:  347:                        }
        -:  348:                    }
        -:  349:                }
        -:  350:            }
        -:  351:
       28:  352:        } else if (choice == 2 && molecule_enabled && server_connected) {
        -:  353:            // Request molecules (via datagram connection)
        -:  354:            int mol_choice;
       23:  355:            while (server_connected) {
       23:  356:                show_molecule_menu();
      23*:  357:                if (scanf("%d", &mol_choice) != 1) { 
    #####:  358:                    while (getchar() != '\n'); 
       2*:  359:                    continue; 
        -:  360:                }
       23:  361:                while (getchar() != '\n');
        -:  362:
       23:  363:                if (mol_choice == 5) break;
        -:  364:
        -:  365:                const char *mol;
       16:  366:                switch (mol_choice) {
        7:  367:                    case 1: mol = "WATER"; break;
        7:  368:                    case 2: mol = "CARBON DIOXIDE"; break;
    #####:  369:                    case 3: mol = "ALCOHOL"; break;
    #####:  370:                    case 4: mol = "GLUCOSE"; break;
        2:  371:                    default: printf("Invalid molecule choice.\n"); continue;
        -:  372:                }
        -:  373:
        -:  374:                // STRICT quantity validation - NO default fallback
        -:  375:                unsigned long long quantity;
        -:  376:                while (1) {
       16:  377:                    printf("How many %s molecules to request (1-%llu): ", mol, MAX_ATOMS);
       16:  378:                    if (read_unsigned_long_long(&quantity) && quantity > 0 && quantity <= MAX_ATOMS) {
       14:  379:                        break;
        -:  380:                    }
        2:  381:                    printf("Invalid quantity. Please try again.\n");
        -:  382:                }
        -:  383:
       14:  384:                snprintf(buffer, sizeof(buffer), "DELIVER %s %llu\n", mol, quantity);
        -:  385:                
       14:  386:                if (use_network) {
        -:  387:                    // Send via UDP
        -:  388:                    struct sockaddr_in udp_addr;
       14:  389:                    udp_addr.sin_family = AF_INET;
       14:  390:                    udp_addr.sin_port = htons(udp_port);
        -:  391:                    char server_ip[16];
       14:  392:                    hostname_to_ip(server_host, server_ip);
       14:  393:                    inet_pton(AF_INET, server_ip, &udp_addr.sin_addr);
        -:  394:                    
      14*:  395:                    if (sendto(datagram_fd, buffer, strlen(buffer), 0, 
        -:  396:                              (struct sockaddr*)&udp_addr, sizeof(udp_addr)) == -1) {
    #####:  397:                        perror("UDP send failed");
    #####:  398:                        continue;
        -:  399:                    }
        -:  400:                    
       14:  401:                    int n = recvfrom(datagram_fd, recv_buffer, sizeof(recv_buffer) - 1, 0, NULL, NULL);
       14:  402:                    if (n > 0) {
       14:  403:                        recv_buffer[n] = '\0';
       14:  404:                        printf("Server: %s", recv_buffer);
        -:  405:                    } else {
    #####:  406:                        perror("UDP receive failed");
        -:  407:                    }
        -:  408:                } else {
        -:  409:                    // Send via UDS datagram
        -:  410:                    struct sockaddr_un dgram_addr;
    #####:  411:                    memset(&dgram_addr, 0, sizeof(dgram_addr));
    #####:  412:                    dgram_addr.sun_family = AF_UNIX;
    #####:  413:                    strncpy(dgram_addr.sun_path, uds_datagram_path, sizeof(dgram_addr.sun_path) - 1);
        -:  414:                    
    #####:  415:                    if (sendto(datagram_fd, buffer, strlen(buffer), 0, 
        -:  416:                              (struct sockaddr*)&dgram_addr, sizeof(dgram_addr)) == -1) {
    #####:  417:                        perror("UDS datagram send failed");
    #####:  418:                        continue;
        -:  419:                    }
        -:  420:                    
    #####:  421:                    int n = recvfrom(datagram_fd, recv_buffer, sizeof(recv_buffer) - 1, 0, NULL, NULL);
    #####:  422:                    if (n > 0) {
    #####:  423:                        recv_buffer[n] = '\0';
    #####:  424:                        printf("Server: %s", recv_buffer);
        -:  425:                    } else {
    #####:  426:                        perror("UDS datagram receive failed");
        -:  427:                    }
        -:  428:                }
        -:  429:            }
        -:  430:
       14:  431:        } else if (choice == 3) {
       11:  432:            running = 0;
        -:  433:        } else {
        3:  434:            printf("Invalid choice.\n");
        -:  435:        }
        -:  436:    }
        -:  437:
       11:  438:    close(stream_fd);
       11:  439:    if (datagram_fd != -1) close(datagram_fd);
        -:  440:    
       11:  441:    if (!server_connected) {
    #####:  442:        printf("Connection to server lost.\n");
        -:  443:    } else {
       11:  444:        printf("Disconnected.\n");
        -:  445:    }
        -:  446:    
       11:  447:    return 0;
        -:  448:}
