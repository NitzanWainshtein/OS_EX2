        -:    0:Source:persistent_requester.c
        -:    1:/**
        -:    2: * persistent_requester.c - Q6 Client - FIXED VERSION
        -:    3: *
        -:    4: * Client with UDS support (both stream and datagram)
        -:    5: * Enhanced with proper server response handling and FIXED input validation
        -:    6: * 
        -:    7: * Usage:
        -:    8: *   ./persistent_requester -h <hostname/IP> -p <tcp_port> [-u <udp_port>]
        -:    9: *   ./persistent_requester -f <UDS_stream_path> [-d <UDS_datagram_path>]
        -:   10: */
        -:   11:
        -:   12:#include <stdio.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <string.h>
        -:   15:#include <unistd.h>
        -:   16:#include <getopt.h>
        -:   17:#include <sys/types.h>
        -:   18:#include <sys/socket.h>
        -:   19:#include <sys/un.h>
        -:   20:#include <netinet/in.h>
        -:   21:#include <arpa/inet.h>
        -:   22:#include <errno.h>
        -:   23:#include <netdb.h>
        -:   24:
        -:   25:#define BUFFER_SIZE 256
        -:   26:#define MAX_ATOMS 1000000000000000000ULL
        -:   27:
        -:   28:/**
        -:   29: * show_usage - displays usage instructions
        -:   30: */
        4:   31:void show_usage(const char *program_name) {
        4:   32:    printf("Usage: %s [network options] [uds options]\n\n", program_name);
        4:   33:    printf("Network options:\n");
        4:   34:    printf("  -h, --host HOST         Server hostname or IP address\n");
        4:   35:    printf("  -p, --port PORT         TCP port\n");
        4:   36:    printf("  -u, --udp-port PORT     UDP port (enables molecule requests)\n\n");
        4:   37:    printf("UDS options:\n");
        4:   38:    printf("  -f, --file PATH         UDS stream socket file path\n");
        4:   39:    printf("  -d, --datagram PATH     UDS datagram socket file path (enables molecule requests)\n");
        4:   40:    printf("\nExamples:\n");
        4:   41:    printf("  %s -h 127.0.0.1 -p 12345 -u 12346\n", program_name);
        4:   42:    printf("  %s -f /tmp/stream.sock -d /tmp/datagram.sock\n", program_name);
        4:   43:    printf("  %s -f /tmp/stream.sock\n", program_name);
        4:   44:}
        -:   45:
        -:   46:/**
        -:   47: * show_main_menu - displays the main menu
        -:   48: */
       16:   49:void show_main_menu(int molecule_enabled) {
       16:   50:    printf("\n=== PERSISTENT WAREHOUSE CLIENT ===\n");
       16:   51:    printf("1. Add atoms\n");
       16:   52:    if (molecule_enabled) printf("2. Request molecule delivery\n");
       16:   53:    printf("3. Quit\n");
       16:   54:    printf("Your choice: ");
       16:   55:}
        -:   56:
        -:   57:/**
        -:   58: * show_atom_menu - displays the atoms menu
        -:   59: */
       16:   60:void show_atom_menu() {
       16:   61:    printf("\n--- ADD ATOMS ---\n");
       16:   62:    printf("1. CARBON\n2. OXYGEN\n3. HYDROGEN\n4. Back\nYour choice: ");
       16:   63:}
        -:   64:
        -:   65:/**
        -:   66: * show_molecule_menu - displays the molecules menu
        -:   67: */
        5:   68:void show_molecule_menu() {
        5:   69:    printf("\n--- REQUEST MOLECULE ---\n");
        5:   70:    printf("1. WATER\n2. CARBON DIOXIDE\n3. ALCOHOL\n4. GLUCOSE\n5. Back\nYour choice: ");
        5:   71:}
        -:   72:
        -:   73:/**
        -:   74: * read_unsigned_long_long - FIXED VERSION - reads a positive number from user
        -:   75: * returns 1 on success, 0 on failure
        -:   76: */
       12:   77:int read_unsigned_long_long(unsigned long long *result) {
        -:   78:    char input[BUFFER_SIZE];
        -:   79:    
       12:   80:    if (!fgets(input, sizeof(input), stdin)) {
    #####:   81:        return 0;
        -:   82:    }
        -:   83:    
        -:   84:    // Remove newline
       12:   85:    char *newline = strchr(input, '\n');
       12:   86:    if (newline) *newline = '\0';
        -:   87:    
        -:   88:    // Skip empty input
       12:   89:    if (strlen(input) == 0) {
    #####:   90:        return 0;
        -:   91:    }
        -:   92:    
        -:   93:    char *endptr;
       12:   94:    errno = 0;
       12:   95:    unsigned long long value = strtoull(input, &endptr, 10);
        -:   96:    
       12:   97:    if (errno != 0 || endptr == input || *endptr != '\0') {
        1:   98:        return 0;
        -:   99:    }
        -:  100:    
       11:  101:    *result = value;
       11:  102:    return 1;
        -:  103:}
        -:  104:
        -:  105:/**
        -:  106: * hostname_to_ip - converts hostname to IP
        -:  107: */
        4:  108:int hostname_to_ip(const char *hostname, char *ip) {
        -:  109:    struct hostent *he;
        -:  110:    struct in_addr addr;
        -:  111:    
        4:  112:    if (inet_aton(hostname, &addr)) {
    #####:  113:        strcpy(ip, hostname);
    #####:  114:        return 0;
        -:  115:    }
        -:  116:    
        4:  117:    he = gethostbyname(hostname);
        4:  118:    if (he == NULL) {
    #####:  119:        return -1;
        -:  120:    }
        -:  121:    
        4:  122:    strcpy(ip, inet_ntoa(*((struct in_addr*)he->h_addr)));
        4:  123:    return 0;
        -:  124:}
        -:  125:
        -:  126:/**
        -:  127: * is_shutdown_message - checks if the server is shutting down
        -:  128: */
        6:  129:int is_shutdown_message(const char *msg) {
       12:  130:    return (strstr(msg, "shutting down") != NULL || 
      12*:  131:            strstr(msg, "shutdown") != NULL ||
        6:  132:            strstr(msg, "closing") != NULL);
        -:  133:}
        -:  134:
        -:  135:/**
        -:  136: * wait_for_additional_messages - waits for additional server messages
        -:  137: */
        6:  138:int wait_for_additional_messages(int stream_fd, int timeout_ms) {
        -:  139:    fd_set read_fds;
        -:  140:    struct timeval timeout;
        -:  141:    
      102:  142:    FD_ZERO(&read_fds);
        6:  143:    FD_SET(stream_fd, &read_fds);
        6:  144:    timeout.tv_sec = timeout_ms / 1000;
        6:  145:    timeout.tv_usec = (timeout_ms % 1000) * 1000;
        -:  146:    
        6:  147:    return select(stream_fd + 1, &read_fds, NULL, NULL, &timeout) > 0;
        -:  148:}
        -:  149:
       18:  150:int main(int argc, char *argv[]) {
        -:  151:    // Configuration variables
       18:  152:    char *server_host = NULL;
       18:  153:    int tcp_port = -1, udp_port = -1;
       18:  154:    char *uds_stream_path = NULL, *uds_datagram_path = NULL;
       18:  155:    int use_uds = 0, use_network = 0;
        -:  156:    
        -:  157:    // Parse arguments
        -:  158:    int opt;
       46:  159:    while ((opt = getopt(argc, argv, "h:p:u:f:d:")) != -1) {
       31:  160:        switch (opt) {
       12:  161:            case 'h':
       12:  162:                server_host = optarg;
       12:  163:                use_network = 1;
       12:  164:                break;
       12:  165:            case 'p':
       12:  166:                tcp_port = atoi(optarg);
       12:  167:                if (tcp_port <= 0 || tcp_port > 65535) {
        2:  168:                    fprintf(stderr, "Error: Invalid TCP port: %s\n", optarg);
        2:  169:                    exit(EXIT_FAILURE);
        -:  170:                }
       10:  171:                use_network = 1;
       10:  172:                break;
        3:  173:            case 'u':
        3:  174:                udp_port = atoi(optarg);
        3:  175:                if (udp_port <= 0 || udp_port > 65535) {
    #####:  176:                    fprintf(stderr, "Error: Invalid UDP port: %s\n", optarg);
    #####:  177:                    exit(EXIT_FAILURE);
        -:  178:                }
        3:  179:                use_network = 1;
        3:  180:                break;
        3:  181:            case 'f':
        3:  182:                uds_stream_path = optarg;
        3:  183:                use_uds = 1;
        3:  184:                break;
    #####:  185:            case 'd':
    #####:  186:                uds_datagram_path = optarg;
    #####:  187:                use_uds = 1;
    #####:  188:                break;
        1:  189:            default:
        1:  190:                show_usage(argv[0]);
        1:  191:                exit(EXIT_FAILURE);
        -:  192:        }
        -:  193:    }
        -:  194:    
        -:  195:    // Validate arguments
       15:  196:    if (use_uds && use_network) {
    #####:  197:        fprintf(stderr, "Error: Cannot use both UDS socket files and network address/port\n");
    #####:  198:        exit(EXIT_FAILURE);
        -:  199:    }
        -:  200:    
       15:  201:    if (use_network) {
       11:  202:        if (!server_host || tcp_port == -1) {
        2:  203:            fprintf(stderr, "Error: Server hostname/IP and TCP port are required for network connection\n");
        2:  204:            show_usage(argv[0]);
        2:  205:            exit(EXIT_FAILURE);
        -:  206:        }
        9:  207:        if (udp_port != -1 && tcp_port == udp_port) {
        1:  208:            fprintf(stderr, "Error: TCP and UDP ports must be different\n");
        1:  209:            exit(EXIT_FAILURE);
        -:  210:        }
        4:  211:    } else if (use_uds) {
        3:  212:        if (!uds_stream_path) {
    #####:  213:            fprintf(stderr, "Error: UDS stream socket file path is required (-f option)\n");
    #####:  214:            show_usage(argv[0]);
    #####:  215:            exit(EXIT_FAILURE);
        -:  216:        }
        -:  217:    } else {
        1:  218:        fprintf(stderr, "Error: Must specify either network connection or UDS connection\n");
        1:  219:        show_usage(argv[0]);
        1:  220:        exit(EXIT_FAILURE);
        -:  221:    }
        -:  222:    
        -:  223:    // Setup connections
       11:  224:    int stream_fd = -1, datagram_fd = -1;
       11:  225:    int molecule_enabled = 0;
        -:  226:    
       11:  227:    if (use_network) {
        -:  228:        // TCP connection using getaddrinfo
        -:  229:        struct addrinfo hints, *servinfo, *p;
        -:  230:        int rv;
        -:  231:        
        8:  232:        memset(&hints, 0, sizeof hints);
        8:  233:        hints.ai_family = AF_INET;
        8:  234:        hints.ai_socktype = SOCK_STREAM;
        -:  235:        
        -:  236:        char port_str[6];
        8:  237:        snprintf(port_str, sizeof(port_str), "%d", tcp_port);
        -:  238:        
        8:  239:        if ((rv = getaddrinfo(server_host, port_str, &hints, &servinfo)) != 0) {
        1:  240:            fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        1:  241:            exit(EXIT_FAILURE);
        -:  242:        }
        -:  243:        
        -:  244:        // Connection attempt
        8:  245:        for(p = servinfo; p != NULL; p = p->ai_next) {
       7*:  246:            if ((stream_fd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
    #####:  247:                perror("socket");
    #####:  248:                continue;
        -:  249:            }
        -:  250:            
        7:  251:            if (connect(stream_fd, p->ai_addr, p->ai_addrlen) == -1) {
        1:  252:                close(stream_fd);
        1:  253:                perror("connect");
        1:  254:                continue;
        -:  255:            }
        -:  256:            
        6:  257:            break;
        -:  258:        }
        -:  259:        
        7:  260:        if (p == NULL) {
        1:  261:            fprintf(stderr, "Failed to connect to server\n");
        1:  262:            freeaddrinfo(servinfo);
        1:  263:            exit(EXIT_FAILURE);
        -:  264:        }
        -:  265:        
        -:  266:        char server_ip[INET_ADDRSTRLEN];
        6:  267:        struct sockaddr_in *addr = (struct sockaddr_in *)p->ai_addr;
        6:  268:        inet_ntop(AF_INET, &(addr->sin_addr), server_ip, INET_ADDRSTRLEN);
        -:  269:        
        6:  270:        freeaddrinfo(servinfo);
        -:  271:        
        6:  272:        printf("Connected to TCP server at %s:%d", server_ip, tcp_port);
        -:  273:        
        -:  274:        // UDP connection (optional)
        6:  275:        if (udp_port != -1) {
        2:  276:            datagram_fd = socket(AF_INET, SOCK_DGRAM, 0);
        2:  277:            if (datagram_fd < 0) {
    #####:  278:                perror("UDP socket creation failed");
    #####:  279:                close(stream_fd);
    #####:  280:                exit(EXIT_FAILURE);
        -:  281:            }
        2:  282:            molecule_enabled = 1;
        2:  283:            printf(", UDP:%d", udp_port);
        -:  284:        }
        6:  285:        printf("\n");
        -:  286:        
        -:  287:    } else {
        -:  288:        // UDS stream connection
        3:  289:        stream_fd = socket(AF_UNIX, SOCK_STREAM, 0);
        3:  290:        if (stream_fd < 0) {
    #####:  291:            perror("UDS stream socket creation failed");
    #####:  292:            exit(EXIT_FAILURE);
        -:  293:        }
        -:  294:        
        -:  295:        struct sockaddr_un stream_addr;
        3:  296:        memset(&stream_addr, 0, sizeof(stream_addr));
        3:  297:        stream_addr.sun_family = AF_UNIX;
        3:  298:        strncpy(stream_addr.sun_path, uds_stream_path, sizeof(stream_addr.sun_path) - 1);
        -:  299:        
        3:  300:        if (connect(stream_fd, (struct sockaddr*)&stream_addr, sizeof(stream_addr)) < 0) {
        2:  301:            perror("UDS stream connection failed");
        2:  302:            close(stream_fd);
        2:  303:            exit(EXIT_FAILURE);
        -:  304:        }
        -:  305:        
        1:  306:        printf("Connected to UDS stream server at %s", uds_stream_path);
        -:  307:        
        -:  308:        // UDS datagram connection (optional)
        1:  309:        if (uds_datagram_path) {
    #####:  310:            datagram_fd = socket(AF_UNIX, SOCK_DGRAM, 0);
    #####:  311:            if (datagram_fd < 0) {
    #####:  312:                perror("UDS datagram socket creation failed");
    #####:  313:                close(stream_fd);
    #####:  314:                exit(EXIT_FAILURE);
        -:  315:            }
    #####:  316:            molecule_enabled = 1;
    #####:  317:            printf(", datagram:%s", uds_datagram_path);
        -:  318:        }
        1:  319:        printf("\n");
        -:  320:    }
        -:  321:
        -:  322:    // Read and display welcome message
        -:  323:    char recv_buffer[BUFFER_SIZE];
        7:  324:    int n = recv(stream_fd, recv_buffer, sizeof(recv_buffer) - 1, 0);
        7:  325:    if (n > 0) {
        7:  326:        recv_buffer[n] = '\0';
        7:  327:        printf("Server: %s", recv_buffer);
        -:  328:    }
        -:  329:
        -:  330:    // Main program loop
        7:  331:    int running = 1;
        7:  332:    int server_connected = 1;
        -:  333:    char buffer[BUFFER_SIZE];
        -:  334:    
       23:  335:    while (running && server_connected) {
       16:  336:        show_main_menu(molecule_enabled);
        -:  337:        int choice;
       16:  338:        if (scanf("%d", &choice) != 1) { 
      109:  339:            while (getchar() != '\n'); 
        2:  340:            printf("Invalid input. Please enter a number.\n");
        2:  341:            continue; 
        -:  342:        }
       14:  343:        while (getchar() != '\n');
        -:  344:
       14:  345:        if (choice == 1) {
        -:  346:            // Add atoms (via stream connection)
        -:  347:            int atom_choice;
       16:  348:            while (server_connected) {
       16:  349:                show_atom_menu();
       16:  350:                if (scanf("%d", &atom_choice) != 1) { 
        8:  351:                    while (getchar() != '\n'); 
        1:  352:                    printf("Invalid input. Please enter a number.\n");
        5:  353:                    continue; 
        -:  354:                }
       15:  355:                while (getchar() != '\n');
        -:  356:
       16:  357:                if (atom_choice == 4) break;
        -:  358:
        -:  359:                const char *atom;
       11:  360:                switch (atom_choice) {
        5:  361:                    case 1: atom = "CARBON"; break;
        2:  362:                    case 2: atom = "OXYGEN"; break;
        1:  363:                    case 3: atom = "HYDROGEN"; break;
        3:  364:                    default: 
        3:  365:                        printf("Invalid atom choice (1-4).\n"); 
        3:  366:                        continue;
        -:  367:                }
        -:  368:
        8:  369:                printf("Amount to add (max %llu): ", MAX_ATOMS);
        -:  370:                unsigned long long amount;
        8:  371:                if (!read_unsigned_long_long(&amount) || amount == 0 || amount > MAX_ATOMS) {
        1:  372:                    printf("Invalid amount. Please enter a positive number up to %llu.\n", MAX_ATOMS); 
        1:  373:                    continue;
        -:  374:                }
        -:  375:
        7:  376:                snprintf(buffer, sizeof(buffer), "ADD %s %llu\n", atom, amount);
        7:  377:                if (send(stream_fd, buffer, strlen(buffer), 0) == -1) {
    #####:  378:                    perror("Stream send failed");
    #####:  379:                    server_connected = 0;
    #####:  380:                    break;
        -:  381:                }
        -:  382:                
        -:  383:                // Receive and display server response
        7:  384:                n = recv(stream_fd, recv_buffer, sizeof(recv_buffer) - 1, 0);
        7:  385:                if (n <= 0) {
        1:  386:                    if (n == 0) {
        1:  387:                        printf("Server disconnected.\n");
        -:  388:                    } else {
    #####:  389:                        perror("Stream receive failed");
        -:  390:                    }
        1:  391:                    server_connected = 0;
        1:  392:                    break;
        -:  393:                } else {
        6:  394:                    recv_buffer[n] = '\0';
        6:  395:                    printf("Server: %s", recv_buffer);
        -:  396:                    
        6:  397:                    if (is_shutdown_message(recv_buffer)) {
    #####:  398:                        printf("Server is shutting down. Disconnecting...\n");
    #####:  399:                        server_connected = 0;
    #####:  400:                        break;
        -:  401:                    }
        -:  402:                    
        -:  403:                    // Attempt to receive additional messages (like status updates)
        6:  404:                    if (wait_for_additional_messages(stream_fd, 100)) {
    #####:  405:                        n = recv(stream_fd, recv_buffer, sizeof(recv_buffer) - 1, 0);
    #####:  406:                        if (n > 0) {
    #####:  407:                            recv_buffer[n] = '\0';
    #####:  408:                            printf("Server: %s", recv_buffer);
        -:  409:                        }
        -:  410:                    }
        -:  411:                }
        -:  412:            }
        -:  413:
       10:  414:        } else if (choice == 2 && molecule_enabled && server_connected) {
        -:  415:            // Request molecules (via datagram connection)
        -:  416:            int mol_choice;
        5:  417:            while (server_connected) {
        5:  418:                show_molecule_menu();
       5*:  419:                if (scanf("%d", &mol_choice) != 1) { 
    #####:  420:                    while (getchar() != '\n'); 
    #####:  421:                    printf("Invalid input. Please enter a number.\n");
    #####:  422:                    continue; 
        -:  423:                }
        5:  424:                while (getchar() != '\n');
        -:  425:
        5:  426:                if (mol_choice == 5) break;
        -:  427:
        -:  428:                const char *mol;
       4*:  429:                switch (mol_choice) {
        1:  430:                    case 1: mol = "WATER"; break;
        1:  431:                    case 2: mol = "CARBON DIOXIDE"; break;
        1:  432:                    case 3: mol = "ALCOHOL"; break;
        1:  433:                    case 4: mol = "GLUCOSE"; break;
    #####:  434:                    default: 
    #####:  435:                        printf("Invalid molecule choice (1-5).\n"); 
    #####:  436:                        continue;
        -:  437:                }
        -:  438:
        -:  439:                // FIXED quantity validation - no infinite loop!
        4:  440:                unsigned long long quantity = 1; // Default value
        4:  441:                int attempts = 0;
        4:  442:                int max_attempts = 3;
        -:  443:                
        4:  444:                while (attempts < max_attempts) {
        4:  445:                    printf("How many %s molecules to request (1-%llu): ", mol, MAX_ATOMS);
        4:  446:                    if (read_unsigned_long_long(&quantity) && quantity > 0 && quantity <= MAX_ATOMS) {
        4:  447:                        break;
        -:  448:                    }
    #####:  449:                    attempts++;
    #####:  450:                    if (attempts < max_attempts) {
    #####:  451:                        printf("Invalid quantity. Please try again.\n");
        -:  452:                    } else {
    #####:  453:                        printf("Too many invalid attempts. Using default quantity: 1\n");
    #####:  454:                        quantity = 1;
        -:  455:                    }
        -:  456:                }
        -:  457:
        4:  458:                snprintf(buffer, sizeof(buffer), "DELIVER %s %llu\n", mol, quantity);
        -:  459:                
        4:  460:                if (use_network) {
        -:  461:                    // Send via UDP
        -:  462:                    struct sockaddr_in udp_addr;
        4:  463:                    udp_addr.sin_family = AF_INET;
        4:  464:                    udp_addr.sin_port = htons(udp_port);
        -:  465:                    char server_ip[16];
        4:  466:                    hostname_to_ip(server_host, server_ip);
        4:  467:                    inet_pton(AF_INET, server_ip, &udp_addr.sin_addr);
        -:  468:                    
       4*:  469:                    if (sendto(datagram_fd, buffer, strlen(buffer), 0, 
        -:  470:                              (struct sockaddr*)&udp_addr, sizeof(udp_addr)) == -1) {
    #####:  471:                        perror("UDP send failed");
    #####:  472:                        continue;
        -:  473:                    }
        -:  474:                    
        4:  475:                    n = recvfrom(datagram_fd, recv_buffer, sizeof(recv_buffer) - 1, 0, NULL, NULL);
        4:  476:                    if (n > 0) {
        4:  477:                        recv_buffer[n] = '\0';
        4:  478:                        printf("Server: %s", recv_buffer);
        -:  479:                    } else {
    #####:  480:                        perror("UDP receive failed");
        -:  481:                    }
        -:  482:                } else {
        -:  483:                    // Send via UDS datagram
        -:  484:                    struct sockaddr_un dgram_addr;
    #####:  485:                    memset(&dgram_addr, 0, sizeof(dgram_addr));
    #####:  486:                    dgram_addr.sun_family = AF_UNIX;
    #####:  487:                    strncpy(dgram_addr.sun_path, uds_datagram_path, sizeof(dgram_addr.sun_path) - 1);
        -:  488:                    
    #####:  489:                    if (sendto(datagram_fd, buffer, strlen(buffer), 0, 
        -:  490:                              (struct sockaddr*)&dgram_addr, sizeof(dgram_addr)) == -1) {
    #####:  491:                        perror("UDS datagram send failed");
    #####:  492:                        continue;
        -:  493:                    }
        -:  494:                    
    #####:  495:                    n = recvfrom(datagram_fd, recv_buffer, sizeof(recv_buffer) - 1, 0, NULL, NULL);
    #####:  496:                    if (n > 0) {
    #####:  497:                        recv_buffer[n] = '\0';
    #####:  498:                        printf("Server: %s", recv_buffer);
        -:  499:                    } else {
    #####:  500:                        perror("UDS datagram receive failed");
        -:  501:                    }
        -:  502:                }
        -:  503:            }
        -:  504:
        8:  505:        } else if (choice == 3) {
        6:  506:            running = 0;
        2:  507:        } else if (choice == 2 && !molecule_enabled) {
        2:  508:            printf("Molecule requests not available (no datagram connection configured).\n");
        -:  509:        } else {
    #####:  510:            printf("Invalid choice. Please select from the available options.\n");
        -:  511:        }
        -:  512:    }
        -:  513:
        -:  514:    // Cleanup resources
        7:  515:    if (stream_fd != -1) close(stream_fd);
        7:  516:    if (datagram_fd != -1) close(datagram_fd);
        -:  517:    
        7:  518:    if (!server_connected) {
        1:  519:        printf("Connection to server lost.\n");
        -:  520:    } else {
        6:  521:        printf("Disconnected from server.\n");
        -:  522:    }
        -:  523:    
        7:  524:    return 0;
        -:  525:}
