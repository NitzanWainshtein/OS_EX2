        -:    0:Source:persistent_warehouse.c
        -:    1:/**
        -:    2: * persistent_warehouse.c - Q6
        -:    3: * 
        -:    4: * Warehouse server with persistent storage and multiple process support
        -:    5: * Enhanced with proper client feedback and strict input validation
        -:    6: * 
        -:    7: * Features:
        -:    8: * - Persistent storage using memory-mapped files
        -:    9: * - Support for both TCP/UDP and UDS stream/datagram
        -:   10: * - File locking for concurrent access
        -:   11: * - Automatic inventory synchronization
        -:   12: * - Comprehensive error handling
        -:   13: * - Welcome messages for connecting clients
        -:   14: * 
        -:   15: * Usage:
        -:   16: *   ./persistent_warehouse -T <tcp_port> -U <udp_port> -f <save_file> [options]
        -:   17: *   ./persistent_warehouse -s <stream_path> -d <datagram_path> -f <save_file> [options]
        -:   18: * 
        -:   19: * Options:
        -:   20: *   -T, --tcp-port PORT         TCP port for stream connections
        -:   21: *   -U, --udp-port PORT         UDP port for datagram requests
        -:   22: *   -s, --stream-path PATH      UDS stream socket path
        -:   23: *   -d, --datagram-path PATH    UDS datagram socket path
        -:   24: *   -f, --save-file PATH        Save file path (required)
        -:   25: *   -c, --carbon NUM            Initial carbon atoms (default: 0)
        -:   26: *   -o, --oxygen NUM            Initial oxygen atoms (default: 0)
        -:   27: *   -H, --hydrogen NUM          Initial hydrogen atoms (default: 0)
        -:   28: *   -t, --timeout SEC           Timeout in seconds (default: no timeout)
        -:   29: * 
        -:   30: * Commands (TCP/UDS stream):
        -:   31: *   ADD CARBON <amount>         Add carbon atoms
        -:   32: *   ADD OXYGEN <amount>         Add oxygen atoms
        -:   33: *   ADD HYDROGEN <amount>       Add hydrogen atoms
        -:   34: * 
        -:   35: * Commands (UDP/UDS datagram):
        -:   36: *   DELIVER WATER <quantity>             Request water molecules
        -:   37: *   DELIVER CARBON DIOXIDE <quantity>    Request CO2 molecules
        -:   38: *   DELIVER ALCOHOL <quantity>           Request alcohol molecules
        -:   39: *   DELIVER GLUCOSE <quantity>           Request glucose molecules
        -:   40: * 
        -:   41: * Admin Commands (stdin):
        -:   42: *   GEN SOFT DRINK              Calculate possible soft drinks
        -:   43: *   GEN VODKA                   Calculate possible vodka
        -:   44: *   GEN CHAMPAGNE               Calculate possible champagne
        -:   45: *   shutdown                    Shutdown server
        -:   46: */
        -:   47:
        -:   48:#include <stdio.h>
        -:   49:#include <stdlib.h>
        -:   50:#include <string.h>
        -:   51:#include <unistd.h>
        -:   52:#include <getopt.h>
        -:   53:#include <signal.h>
        -:   54:#include <fcntl.h>
        -:   55:#include <sys/types.h>
        -:   56:#include <sys/socket.h>
        -:   57:#include <sys/un.h>
        -:   58:#include <sys/mman.h>
        -:   59:#include <sys/stat.h>
        -:   60:#include <netinet/in.h>
        -:   61:#include <arpa/inet.h>
        -:   62:#include <sys/select.h>
        -:   63:#include <errno.h>
        -:   64:
        -:   65:#define MAX_CLIENTS 10
        -:   66:#define BUFFER_SIZE 256
        -:   67:#define MAX_ATOMS 1000000000000000000ULL
        -:   68:
        -:   69:// Global flag for timeout
        -:   70:volatile int timeout_occurred = 0;
        -:   71:
        -:   72:// Inventory structure for memory mapping
        -:   73:typedef struct {
        -:   74:    unsigned long long carbon;
        -:   75:    unsigned long long oxygen;
        -:   76:    unsigned long long hydrogen;
        -:   77:    int magic;  // For file validation
        -:   78:} inventory_t;
        -:   79:
        -:   80:#define INVENTORY_MAGIC 0x12345678
        -:   81:
        -:   82:// Global pointer to memory-mapped inventory
        -:   83:inventory_t *inventory = NULL;
        -:   84:int inventory_fd = -1;
        -:   85:char *save_file_path = NULL;
        -:   86:
        -:   87:/**
        -:   88: * timeout_handler - Handles the alarm signal for server timeout
        -:   89: * @sig: Signal number (unused but required by signal handler signature)
        -:   90: * 
        -:   91: * Sets the global timeout flag to indicate timeout has occurred.
        -:   92: */
    #####:   93:void timeout_handler(int sig) {
        -:   94:    (void)sig;  // Prevent compiler warning
    #####:   95:    timeout_occurred = 1;
    #####:   96:}
        -:   97:
        -:   98:/**
        -:   99: * min3 - Finds the minimum value among three unsigned long long values
        -:  100: * @a: First value
        -:  101: * @b: Second value
        -:  102: * @c: Third value
        -:  103: * 
        -:  104: * Returns: The smallest of the three values
        -:  105: */
    #####:  106:unsigned long long min3(unsigned long long a, unsigned long long b, unsigned long long c) {
    #####:  107:    unsigned long long min_ab = (a < b) ? a : b;
    #####:  108:    return (min_ab < c) ? min_ab : c;
        -:  109:}
        -:  110:
        -:  111:/**
        -:  112: * show_usage - Displays program usage instructions
        -:  113: * @program_name: Name of the program executable
        -:  114: */
        4:  115:void show_usage(const char *program_name) {
        4:  116:    printf("Usage: %s [network options] [uds options] [general options]\n\n", program_name);
        4:  117:    printf("Network options:\n");
        4:  118:    printf("  -T, --tcp-port PORT     TCP port\n");
        4:  119:    printf("  -U, --udp-port PORT     UDP port\n\n");
        4:  120:    printf("UDS options:\n");
        4:  121:    printf("  -s, --stream-path PATH  UDS stream socket path\n");
        4:  122:    printf("  -d, --datagram-path PATH UDS datagram socket path\n\n");
        4:  123:    printf("General options:\n");
        4:  124:    printf("  -f, --save-file PATH    Save file path (required)\n");
        4:  125:    printf("  -c, --carbon NUM        Initial carbon atoms (default: 0)\n");
        4:  126:    printf("  -o, --oxygen NUM        Initial oxygen atoms (default: 0)\n");
        4:  127:    printf("  -H, --hydrogen NUM      Initial hydrogen atoms (default: 0)\n");
        4:  128:    printf("  -t, --timeout SEC       Timeout in seconds (default: no timeout)\n");
        4:  129:    printf("\nExamples:\n");
        4:  130:    printf("  %s -T 12345 -U 12346 -f /tmp/inventory.dat\n", program_name);
        4:  131:    printf("  %s -s /tmp/stream.sock -d /tmp/datagram.sock -f /tmp/inventory.dat\n", program_name);
        4:  132:}
        -:  133:
        -:  134:/**
        -:  135: * init_inventory_file - Initializes or loads the inventory from a file
        -:  136: * @filepath: Path to the inventory file
        -:  137: * @carbon: Initial carbon atoms (used if file doesn't exist)
        -:  138: * @oxygen: Initial oxygen atoms (used if file doesn't exist)
        -:  139: * @hydrogen: Initial hydrogen atoms (used if file doesn't exist)
        -:  140: * 
        -:  141: * Creates a new inventory file if it doesn't exist, or loads existing data.
        -:  142: * The file is memory-mapped for efficient access and automatic synchronization.
        -:  143: * 
        -:  144: * Returns: 0 on success, -1 on failure
        -:  145: */
    #####:  146:int init_inventory_file(const char *filepath, unsigned long long carbon, unsigned long long oxygen, unsigned long long hydrogen) {
        -:  147:    // Try to open existing file
    #####:  148:    inventory_fd = open(filepath, O_RDWR);
        -:  149:    
    #####:  150:    if (inventory_fd == -1) {
        -:  151:        // File doesn't exist, create new one
    #####:  152:        printf("Save file doesn't exist, creating new file: %s\n", filepath);
    #####:  153:        inventory_fd = open(filepath, O_RDWR | O_CREAT, 0644);
    #####:  154:        if (inventory_fd == -1) {
    #####:  155:            perror("Failed to create save file");
    #####:  156:            return -1;
        -:  157:        }
        -:  158:        
        -:  159:        // Initialize with provided values
    #####:  160:        inventory_t init_inventory = {
        -:  161:            .carbon = carbon,
        -:  162:            .oxygen = oxygen,
        -:  163:            .hydrogen = hydrogen,
        -:  164:            .magic = INVENTORY_MAGIC
        -:  165:        };
        -:  166:        
    #####:  167:        if (write(inventory_fd, &init_inventory, sizeof(inventory_t)) != sizeof(inventory_t)) {
    #####:  168:            perror("Failed to write initial inventory");
    #####:  169:            close(inventory_fd);
    #####:  170:            return -1;
        -:  171:        }
        -:  172:        
    #####:  173:        printf("Initialized inventory with: Carbon=%llu, Oxygen=%llu, Hydrogen=%llu\n", 
        -:  174:               carbon, oxygen, hydrogen);
        -:  175:    } else {
        -:  176:        // File exists, validate it
    #####:  177:        printf("Loading existing save file: %s\n", filepath);
        -:  178:        inventory_t test_inventory;
    #####:  179:        if (read(inventory_fd, &test_inventory, sizeof(inventory_t)) != sizeof(inventory_t)) {
    #####:  180:            printf("Warning: Invalid save file format, reinitializing...\n");
    #####:  181:            lseek(inventory_fd, 0, SEEK_SET);
    #####:  182:            inventory_t init_inventory = {
        -:  183:                .carbon = carbon,
        -:  184:                .oxygen = oxygen,
        -:  185:                .hydrogen = hydrogen,
        -:  186:                .magic = INVENTORY_MAGIC
        -:  187:            };
    #####:  188:            if (write(inventory_fd, &init_inventory, sizeof(inventory_t)) != sizeof(inventory_t)) {
    #####:  189:                perror("Failed to reinitialize save file");
    #####:  190:                close(inventory_fd);
    #####:  191:                return -1;
        -:  192:            }
    #####:  193:        } else if (test_inventory.magic != INVENTORY_MAGIC) {
    #####:  194:            printf("Warning: Invalid save file magic, reinitializing...\n");
    #####:  195:            lseek(inventory_fd, 0, SEEK_SET);
    #####:  196:            inventory_t init_inventory = {
        -:  197:                .carbon = carbon,
        -:  198:                .oxygen = oxygen,
        -:  199:                .hydrogen = hydrogen,
        -:  200:                .magic = INVENTORY_MAGIC
        -:  201:            };
    #####:  202:            if (write(inventory_fd, &init_inventory, sizeof(inventory_t)) != sizeof(inventory_t)) {
    #####:  203:                perror("Failed to reinitialize save file");
    #####:  204:                close(inventory_fd);
    #####:  205:                return -1;
        -:  206:            }
        -:  207:        } else {
    #####:  208:            printf("Loaded inventory: Carbon=%llu, Oxygen=%llu, Hydrogen=%llu\n", 
        -:  209:                   test_inventory.carbon, test_inventory.oxygen, test_inventory.hydrogen);
        -:  210:        }
        -:  211:    }
        -:  212:    
        -:  213:    // Memory map the file
    #####:  214:    inventory = mmap(NULL, sizeof(inventory_t), PROT_READ | PROT_WRITE, MAP_SHARED, inventory_fd, 0);
    #####:  215:    if (inventory == MAP_FAILED) {
    #####:  216:        perror("Failed to memory map inventory file");
    #####:  217:        close(inventory_fd);
    #####:  218:        return -1;
        -:  219:    }
        -:  220:    
    #####:  221:    return 0;
        -:  222:}
        -:  223:
        -:  224:/**
        -:  225: * save_inventory - Ensures inventory changes are written to disk
        -:  226: * 
        -:  227: * Forces synchronization of the memory-mapped inventory to disk.
        -:  228: */
    #####:  229:void save_inventory() {
    #####:  230:    if (inventory != NULL) {
        -:  231:        // Memory mapped file is automatically synchronized
    #####:  232:        if (msync(inventory, sizeof(inventory_t), MS_SYNC) == -1) {
    #####:  233:            perror("Warning: Failed to sync inventory to disk");
        -:  234:        }
        -:  235:    }
    #####:  236:}
        -:  237:
        -:  238:/**
        -:  239: * cleanup_inventory - Cleans up inventory resources on exit
        -:  240: * 
        -:  241: * Unmaps the memory-mapped file and closes the file descriptor.
        -:  242: * This function is registered with atexit() to ensure proper cleanup.
        -:  243: */
    #####:  244:void cleanup_inventory() {
    #####:  245:    if (inventory != NULL) {
    #####:  246:        save_inventory();
    #####:  247:        munmap(inventory, sizeof(inventory_t));
    #####:  248:        inventory = NULL;
        -:  249:    }
    #####:  250:    if (inventory_fd != -1) {
    #####:  251:        close(inventory_fd);
    #####:  252:        inventory_fd = -1;
        -:  253:    }
    #####:  254:}
        -:  255:
        -:  256:/**
        -:  257: * lock_inventory - Locks the inventory file for exclusive access
        -:  258: * 
        -:  259: * Uses fcntl() with F_SETLKW to obtain an exclusive write lock.
        -:  260: * This ensures multiple processes don't interfere with each other.
        -:  261: */
    #####:  262:void lock_inventory() {
    #####:  263:    if (inventory_fd != -1) {
        -:  264:        struct flock lock;
    #####:  265:        lock.l_type = F_WRLCK;
    #####:  266:        lock.l_whence = SEEK_SET;
    #####:  267:        lock.l_start = 0;
    #####:  268:        lock.l_len = sizeof(inventory_t);
        -:  269:        
    #####:  270:        if (fcntl(inventory_fd, F_SETLKW, &lock) == -1) {
    #####:  271:            perror("Warning: Failed to lock inventory file");
        -:  272:        }
        -:  273:    }
    #####:  274:}
        -:  275:
        -:  276:/**
        -:  277: * unlock_inventory - Releases the lock on the inventory file
        -:  278: * 
        -:  279: * Uses fcntl() with F_UNLCK to release the exclusive lock.
        -:  280: */
    #####:  281:void unlock_inventory() {
    #####:  282:    if (inventory_fd != -1) {
        -:  283:        struct flock lock;
    #####:  284:        lock.l_type = F_UNLCK;
    #####:  285:        lock.l_whence = SEEK_SET;
    #####:  286:        lock.l_start = 0;
    #####:  287:        lock.l_len = sizeof(inventory_t);
        -:  288:        
    #####:  289:        if (fcntl(inventory_fd, F_SETLK, &lock) == -1) {
    #####:  290:            perror("Warning: Failed to unlock inventory file");
        -:  291:        }
        -:  292:    }
    #####:  293:}
        -:  294:
        -:  295:/**
        -:  296: * process_command - Processes an ADD command from the client
        -:  297: * @cmd: Command string from client
        -:  298: * @response_buf: Buffer to store response message
        -:  299: * @response_size: Size of response buffer
        -:  300: * 
        -:  301: * Parses ADD commands and updates the inventory with proper validation.
        -:  302: * Provides detailed feedback to the client including current status.
        -:  303: * 
        -:  304: * Returns: Pointer to the response buffer
        -:  305: */
    #####:  306:char* process_command(char *cmd, char *response_buf, size_t response_size) {
        -:  307:    char type[16];
        -:  308:    unsigned long long amount;
        -:  309:
    #####:  310:    if (sscanf(cmd, "ADD %15s %llu", type, &amount) == 2) {
    #####:  311:        if (amount > MAX_ATOMS) {
    #####:  312:            snprintf(response_buf, response_size, "ERROR: Amount too large, max allowed per command is %llu.\n", MAX_ATOMS);
    #####:  313:            printf("Error: amount too large, max allowed per command is %llu.\n", MAX_ATOMS);
    #####:  314:            return response_buf;
        -:  315:        }
        -:  316:
        -:  317:        // Variables for status message
    #####:  318:        int success = 0;
        -:  319:        unsigned long long final_carbon, final_oxygen, final_hydrogen;
        -:  320:
    #####:  321:        lock_inventory();
        -:  322:        
    #####:  323:        if (strcmp(type, "CARBON") == 0) {
    #####:  324:            if (inventory->carbon + amount > MAX_ATOMS) {
    #####:  325:                snprintf(response_buf, response_size, "ERROR: Adding this would exceed CARBON storage limit (%llu).\n", MAX_ATOMS);
    #####:  326:                printf("Error: adding this would exceed CARBON storage limit (%llu).\n", MAX_ATOMS);
        -:  327:            } else {
    #####:  328:                inventory->carbon += amount;
    #####:  329:                snprintf(response_buf, response_size, "SUCCESS: Added %llu CARBON. Total CARBON: %llu\n", 
    #####:  330:                         amount, inventory->carbon);
    #####:  331:                printf("Added %llu CARBON.\n", amount);
    #####:  332:                success = 1;
        -:  333:            }
    #####:  334:        } else if (strcmp(type, "OXYGEN") == 0) {
    #####:  335:            if (inventory->oxygen + amount > MAX_ATOMS) {
    #####:  336:                snprintf(response_buf, response_size, "ERROR: Adding this would exceed OXYGEN storage limit (%llu).\n", MAX_ATOMS);
    #####:  337:                printf("Error: adding this would exceed OXYGEN storage limit (%llu).\n", MAX_ATOMS);
        -:  338:            } else {
    #####:  339:                inventory->oxygen += amount;
    #####:  340:                snprintf(response_buf, response_size, "SUCCESS: Added %llu OXYGEN. Total OXYGEN: %llu\n", 
    #####:  341:                         amount, inventory->oxygen);
    #####:  342:                printf("Added %llu OXYGEN.\n", amount);
    #####:  343:                success = 1;
        -:  344:            }
    #####:  345:        } else if (strcmp(type, "HYDROGEN") == 0) {
    #####:  346:            if (inventory->hydrogen + amount > MAX_ATOMS) {
    #####:  347:                snprintf(response_buf, response_size, "ERROR: Adding this would exceed HYDROGEN storage limit (%llu).\n", MAX_ATOMS);
    #####:  348:                printf("Error: adding this would exceed HYDROGEN storage limit (%llu).\n", MAX_ATOMS);
        -:  349:            } else {
    #####:  350:                inventory->hydrogen += amount;
    #####:  351:                snprintf(response_buf, response_size, "SUCCESS: Added %llu HYDROGEN. Total HYDROGEN: %llu\n", 
    #####:  352:                         amount, inventory->hydrogen);
    #####:  353:                printf("Added %llu HYDROGEN.\n", amount);
    #####:  354:                success = 1;
        -:  355:            }
        -:  356:        } else {
    #####:  357:            snprintf(response_buf, response_size, "ERROR: Unknown atom type: %s\n", type);
    #####:  358:            printf("Unknown atom type: %s\n", type);
        -:  359:        }
        -:  360:        
    #####:  361:        if (success) {
    #####:  362:            save_inventory();
        -:  363:            
        -:  364:            // Copy current values before unlocking
    #####:  365:            final_carbon = inventory->carbon;
    #####:  366:            final_oxygen = inventory->oxygen;
    #####:  367:            final_hydrogen = inventory->hydrogen;
        -:  368:            
    #####:  369:            unlock_inventory();
        -:  370:            
        -:  371:            // Add status information to the response
        -:  372:            char status_msg[BUFFER_SIZE];
    #####:  373:            snprintf(status_msg, sizeof(status_msg), "Status: CARBON: %llu, OXYGEN: %llu, HYDROGEN: %llu\n", 
        -:  374:                     final_carbon, final_oxygen, final_hydrogen);
        -:  375:            
    #####:  376:            size_t current_len = strlen(response_buf);
    #####:  377:            if (current_len + strlen(status_msg) < response_size) {
    #####:  378:                strcat(response_buf, status_msg);
        -:  379:            }
        -:  380:            
        -:  381:            // Print to server console
    #####:  382:            printf("Current warehouse status:\n");
    #####:  383:            printf("CARBON: %llu\n", final_carbon);
    #####:  384:            printf("OXYGEN: %llu\n", final_oxygen);
    #####:  385:            printf("HYDROGEN: %llu\n", final_hydrogen);
        -:  386:        } else {
    #####:  387:            unlock_inventory();
        -:  388:        }
        -:  389:    } else {
    #####:  390:        snprintf(response_buf, response_size, "ERROR: Invalid command format: %s\n", cmd);
    #####:  391:        printf("Invalid command: %s\n", cmd);
        -:  392:    }
        -:  393:    
    #####:  394:    return response_buf;
        -:  395:}
        -:  396:
        -:  397:/**
        -:  398: * can_deliver - Checks if the requested molecule can be delivered
        -:  399: * @molecule: Type of molecule requested
        -:  400: * @quantity: Number of molecules requested
        -:  401: * 
        -:  402: * Validates that sufficient atoms are available and performs the delivery
        -:  403: * if possible. Updates inventory and saves to disk on successful delivery.
        -:  404: * 
        -:  405: * Molecule formulas:
        -:  406: * - WATER: H2O (2 hydrogen + 1 oxygen)
        -:  407: * - CARBON DIOXIDE: CO2 (1 carbon + 2 oxygen)
        -:  408: * - ALCOHOL: C2H6O (2 carbon + 6 hydrogen + 1 oxygen)
        -:  409: * - GLUCOSE: C6H12O6 (6 carbon + 12 hydrogen + 6 oxygen)
        -:  410: * 
        -:  411: * Returns: 1 if successful, 0 if not enough atoms
        -:  412: */
    #####:  413:int can_deliver(const char *molecule, unsigned long long quantity) {
    #####:  414:    unsigned long long needed_c = 0, needed_o = 0, needed_h = 0;
        -:  415:    
    #####:  416:    if (strcmp(molecule, "WATER") == 0) {
    #####:  417:        needed_h = 2 * quantity;
    #####:  418:        needed_o = 1 * quantity;
    #####:  419:    } else if (strcmp(molecule, "CARBON DIOXIDE") == 0) {
    #####:  420:        needed_c = 1 * quantity;
    #####:  421:        needed_o = 2 * quantity;
    #####:  422:    } else if (strcmp(molecule, "ALCOHOL") == 0) {
    #####:  423:        needed_c = 2 * quantity;
    #####:  424:        needed_h = 6 * quantity;
    #####:  425:        needed_o = 1 * quantity;
    #####:  426:    } else if (strcmp(molecule, "GLUCOSE") == 0) {
    #####:  427:        needed_c = 6 * quantity;
    #####:  428:        needed_h = 12 * quantity;
    #####:  429:        needed_o = 6 * quantity;
        -:  430:    } else {
    #####:  431:        return 0; // Unknown molecule
        -:  432:    }
        -:  433:    
    #####:  434:    lock_inventory();
        -:  435:    
    #####:  436:    if (inventory->carbon >= needed_c && inventory->oxygen >= needed_o && inventory->hydrogen >= needed_h) {
    #####:  437:        inventory->carbon -= needed_c;
    #####:  438:        inventory->oxygen -= needed_o;
    #####:  439:        inventory->hydrogen -= needed_h;
    #####:  440:        save_inventory();
    #####:  441:        unlock_inventory();
    #####:  442:        return 1;
        -:  443:    }
        -:  444:    
    #####:  445:    unlock_inventory();
    #####:  446:    return 0;
        -:  447:}
        -:  448:
        -:  449:/**
        -:  450: * calculate_possible_molecules - Calculates how many molecules can be created
        -:  451: * @water: Pointer to store maximum water molecules
        -:  452: * @co2: Pointer to store maximum CO2 molecules
        -:  453: * @alcohol: Pointer to store maximum alcohol molecules
        -:  454: * @glucose: Pointer to store maximum glucose molecules
        -:  455: * 
        -:  456: * Analyzes current inventory to determine the maximum number of each
        -:  457: * molecule type that can be produced based on available atoms.
        -:  458: */
    #####:  459:void calculate_possible_molecules(unsigned long long *water, unsigned long long *co2, 
        -:  460:                                  unsigned long long *alcohol, unsigned long long *glucose) {
    #####:  461:    lock_inventory();
        -:  462:    
        -:  463:    // WATER: 2H + 1O
    #####:  464:    *water = 0;
    #####:  465:    if (inventory->hydrogen >= 2 && inventory->oxygen >= 1) {
    #####:  466:        unsigned long long from_hydrogen = inventory->hydrogen / 2;
    #####:  467:        unsigned long long from_oxygen = inventory->oxygen;
    #####:  468:        *water = (from_hydrogen < from_oxygen) ? from_hydrogen : from_oxygen;
        -:  469:    }
        -:  470:    
        -:  471:    // CARBON DIOXIDE: 1C + 2O  
    #####:  472:    *co2 = 0;
    #####:  473:    if (inventory->carbon >= 1 && inventory->oxygen >= 2) {
    #####:  474:        unsigned long long from_carbon = inventory->carbon;
    #####:  475:        unsigned long long from_oxygen = inventory->oxygen / 2;
    #####:  476:        *co2 = (from_carbon < from_oxygen) ? from_carbon : from_oxygen;
        -:  477:    }
        -:  478:    
        -:  479:    // ALCOHOL: 2C + 6H + 1O
    #####:  480:    *alcohol = 0;
    #####:  481:    if (inventory->carbon >= 2 && inventory->hydrogen >= 6 && inventory->oxygen >= 1) {
    #####:  482:        unsigned long long from_carbon = inventory->carbon / 2;
    #####:  483:        unsigned long long from_hydrogen = inventory->hydrogen / 6;
    #####:  484:        unsigned long long from_oxygen = inventory->oxygen;
    #####:  485:        *alcohol = min3(from_carbon, from_hydrogen, from_oxygen);
        -:  486:    }
        -:  487:    
        -:  488:    // GLUCOSE: 6C + 12H + 6O
    #####:  489:    *glucose = 0;
    #####:  490:    if (inventory->carbon >= 6 && inventory->hydrogen >= 12 && inventory->oxygen >= 6) {
    #####:  491:        unsigned long long from_carbon = inventory->carbon / 6;
    #####:  492:        unsigned long long from_hydrogen = inventory->hydrogen / 12;
    #####:  493:        unsigned long long from_oxygen = inventory->oxygen / 6;
    #####:  494:        *glucose = min3(from_carbon, from_hydrogen, from_oxygen);
        -:  495:    }
        -:  496:    
    #####:  497:    unlock_inventory();
    #####:  498:}
        -:  499:
        -:  500:/**
        -:  501: * process_drink_command - Processes drink commands from administrator
        -:  502: * @cmd: Command string from stdin
        -:  503: * 
        -:  504: * Handles administrative commands to calculate possible drinks:
        -:  505: * - GEN SOFT DRINK: needs WATER + CARBON DIOXIDE + ALCOHOL
        -:  506: * - GEN VODKA: needs WATER + ALCOHOL + GLUCOSE
        -:  507: * - GEN CHAMPAGNE: needs WATER + CARBON DIOXIDE + GLUCOSE
        -:  508: */
    #####:  509:void process_drink_command(char *cmd) {
    #####:  510:    char *newline = strchr(cmd, '\n');
    #####:  511:    if (newline) *newline = '\0';
        -:  512:    
    #####:  513:    if (strcmp(cmd, "GEN SOFT DRINK") == 0) {
        -:  514:        unsigned long long water, co2, alcohol, glucose;
    #####:  515:        calculate_possible_molecules(&water, &co2, &alcohol, &glucose);
    #####:  516:        unsigned long long possible_soft_drinks = min3(water, co2, alcohol);
    #####:  517:        printf("Can produce %llu SOFT DRINK(s) (needs: WATER + CARBON DIOXIDE + ALCOHOL)\n", possible_soft_drinks);
        -:  518:        
    #####:  519:    } else if (strcmp(cmd, "GEN VODKA") == 0) {
        -:  520:        unsigned long long water, co2, alcohol, glucose;
    #####:  521:        calculate_possible_molecules(&water, &co2, &alcohol, &glucose);
    #####:  522:        unsigned long long possible_vodka = min3(water, alcohol, glucose);
    #####:  523:        printf("Can produce %llu VODKA(s) (needs: WATER + ALCOHOL + GLUCOSE)\n", possible_vodka);
        -:  524:        
    #####:  525:    } else if (strcmp(cmd, "GEN CHAMPAGNE") == 0) {
        -:  526:        unsigned long long water, co2, alcohol, glucose;
    #####:  527:        calculate_possible_molecules(&water, &co2, &alcohol, &glucose);
    #####:  528:        unsigned long long possible_champagne = min3(water, co2, glucose);
    #####:  529:        printf("Can produce %llu CHAMPAGNE(s) (needs: WATER + CARBON DIOXIDE + GLUCOSE)\n", possible_champagne);
        -:  530:        
    #####:  531:    } else if (strcmp(cmd, "shutdown") == 0) {
    #####:  532:        return;
        -:  533:    } else {
    #####:  534:        printf("Unknown command: %s\n", cmd);
    #####:  535:        printf("Available commands: GEN SOFT DRINK, GEN VODKA, GEN CHAMPAGNE, shutdown\n");
        -:  536:    }
        -:  537:}
        -:  538:
        -:  539:/**
        -:  540: * handle_molecule_request - Handles DELIVER requests for molecules
        -:  541: * @buffer: Request buffer from client
        -:  542: * @req_fd: Socket file descriptor for response
        -:  543: * @client_addr: Client address structure
        -:  544: * @addrlen: Length of client address
        -:  545: * 
        -:  546: * Processes molecule delivery requests from UDP/UDS datagram clients.
        -:  547: * Validates input, attempts delivery, and sends detailed response including
        -:  548: * current inventory status.
        -:  549: */
    #####:  550:void handle_molecule_request(char *buffer, int req_fd, struct sockaddr *client_addr, socklen_t addrlen) {
    #####:  551:    printf("Received molecule request: %s\n", buffer);
        -:  552:
        -:  553:    char molecule[64];
    #####:  554:    unsigned long long quantity = 1;
        -:  555:    
    #####:  556:    int parsed = sscanf(buffer, "DELIVER %63s %llu", molecule, &quantity);
        -:  557:    
    #####:  558:    if (parsed >= 1) {
        -:  559:        // Handle "CARBON DIOXIDE" as two words
    #####:  560:        if (strcmp(molecule, "CARBON") == 0) {
        -:  561:            char dioxide[32];
    #####:  562:            if (sscanf(buffer, "DELIVER CARBON %31s %llu", dioxide, &quantity) >= 2 && 
    #####:  563:                strcmp(dioxide, "DIOXIDE") == 0) {
    #####:  564:                strcpy(molecule, "CARBON DIOXIDE");
    #####:  565:            } else if (sscanf(buffer, "DELIVER CARBON %31s", dioxide) == 1 && 
    #####:  566:                      strcmp(dioxide, "DIOXIDE") == 0) {
    #####:  567:                strcpy(molecule, "CARBON DIOXIDE");
    #####:  568:                quantity = 1;
        -:  569:            }
        -:  570:        }
        -:  571:        
    #####:  572:        if (parsed == 1) {
    #####:  573:            quantity = 1;
        -:  574:        }
        -:  575:        
        -:  576:        // Strict quantity validation - no defaults for invalid values
    #####:  577:        if (quantity == 0 || quantity > MAX_ATOMS) {
        -:  578:            char error_msg[BUFFER_SIZE];
    #####:  579:            snprintf(error_msg, sizeof(error_msg), "ERROR: Invalid quantity %llu (must be 1-%llu).\n", quantity, MAX_ATOMS);
    #####:  580:            sendto(req_fd, error_msg, strlen(error_msg), 0, client_addr, addrlen);
    #####:  581:            printf("Invalid quantity for %s: %llu\n", molecule, quantity);
    #####:  582:            return;
        -:  583:        }
        -:  584:        
    #####:  585:        if (can_deliver(molecule, quantity)) {
        -:  586:            char success_msg[BUFFER_SIZE];
    #####:  587:            if (quantity == 1) {
    #####:  588:                snprintf(success_msg, sizeof(success_msg), 
        -:  589:                        "SUCCESS: Molecule delivered successfully.\n");
        -:  590:            } else {
    #####:  591:                snprintf(success_msg, sizeof(success_msg), 
        -:  592:                        "SUCCESS: Delivered %llu %s successfully.\n", quantity, molecule);
        -:  593:            }
        -:  594:            
        -:  595:            // Add current status to response
    #####:  596:            lock_inventory();
    #####:  597:            unsigned long long c = inventory->carbon;
    #####:  598:            unsigned long long o = inventory->oxygen;
    #####:  599:            unsigned long long h = inventory->hydrogen;
    #####:  600:            unlock_inventory();
        -:  601:            
        -:  602:            char status_msg[BUFFER_SIZE];
    #####:  603:            snprintf(status_msg, sizeof(status_msg), "Status: CARBON: %llu, OXYGEN: %llu, HYDROGEN: %llu\n", c, o, h);
        -:  604:            
    #####:  605:            if (strlen(success_msg) + strlen(status_msg) < BUFFER_SIZE) {
    #####:  606:                strcat(success_msg, status_msg);
        -:  607:            }
        -:  608:            
    #####:  609:            sendto(req_fd, success_msg, strlen(success_msg), 0, client_addr, addrlen);
    #####:  610:            printf("Delivered %llu %s.\n", quantity, molecule);
        -:  611:            
    #####:  612:            printf("Current warehouse status:\n");
    #####:  613:            printf("CARBON: %llu\n", c);
    #####:  614:            printf("OXYGEN: %llu\n", o);
    #####:  615:            printf("HYDROGEN: %llu\n", h);
        -:  616:        } else {
    #####:  617:            char fail_msg[] = "ERROR: Not enough atoms for this molecule.\n";
    #####:  618:            sendto(req_fd, fail_msg, strlen(fail_msg), 0, client_addr, addrlen);
    #####:  619:            printf("Failed to deliver %llu %s: insufficient atoms.\n", quantity, molecule);
        -:  620:        }
        -:  621:    } else {
    #####:  622:        char error_msg[] = "ERROR: Invalid DELIVER command.\n";
    #####:  623:        sendto(req_fd, error_msg, strlen(error_msg), 0, client_addr, addrlen);
    #####:  624:        printf("Invalid request command.\n");
        -:  625:    }
        -:  626:}
        -:  627:
        -:  628:/**
        -:  629: * main - Main server function
        -:  630: * @argc: Argument count
        -:  631: * @argv: Argument vector
        -:  632: * 
        -:  633: * Initializes the persistent warehouse server with the following features:
        -:  634: * - Command-line argument parsing
        -:  635: * - Persistent inventory file management
        -:  636: * - Multiple socket types (TCP/UDP, UDS stream/datagram)
        -:  637: * - Concurrent client handling using select()
        -:  638: * - Administrative command processing
        -:  639: * - Graceful shutdown handling
        -:  640: * 
        -:  641: * Returns: 0 on success, non-zero on error
        -:  642: */
        7:  643:int main(int argc, char *argv[]) {
        -:  644:    // Default values
        7:  645:    int tcp_port = -1, udp_port = -1;
        7:  646:    char *stream_path = NULL, *datagram_path = NULL;
        7:  647:    unsigned long long carbon = 0, oxygen = 0, hydrogen = 0;
        7:  648:    int timeout_seconds = 0;
        -:  649:    
        -:  650:    // Long options
        -:  651:    static struct option long_options[] = {
        -:  652:        {"tcp-port", required_argument, 0, 'T'},
        -:  653:        {"udp-port", required_argument, 0, 'U'},
        -:  654:        {"stream-path", required_argument, 0, 's'},
        -:  655:        {"datagram-path", required_argument, 0, 'd'},
        -:  656:        {"save-file", required_argument, 0, 'f'},
        -:  657:        {"carbon", required_argument, 0, 'c'},
        -:  658:        {"oxygen", required_argument, 0, 'o'},
        -:  659:        {"hydrogen", required_argument, 0, 'H'},
        -:  660:        {"timeout", required_argument, 0, 't'},
        -:  661:        {"help", no_argument, 0, '?'},
        -:  662:        {0, 0, 0, 0}
        -:  663:    };
        -:  664:    
        -:  665:    int opt;
       12:  666:    while ((opt = getopt_long(argc, argv, "T:U:s:d:f:c:o:H:t:", long_options, NULL)) != -1) {
        8:  667:        switch (opt) {
        4:  668:            case 'T':
        4:  669:                tcp_port = atoi(optarg);
        4:  670:                if (tcp_port <= 0 || tcp_port > 65535) {
        2:  671:                    fprintf(stderr, "Error: Invalid TCP port: %s\n", optarg);
        2:  672:                    exit(EXIT_FAILURE);
        -:  673:                }
        2:  674:                break;
        1:  675:            case 'U':
        1:  676:                udp_port = atoi(optarg);
        1:  677:                if (udp_port <= 0 || udp_port > 65535) {
    #####:  678:                    fprintf(stderr, "Error: Invalid UDP port: %s\n", optarg);
    #####:  679:                    exit(EXIT_FAILURE);
        -:  680:                }
        1:  681:                break;
    #####:  682:            case 's':
    #####:  683:                stream_path = strdup(optarg);
    #####:  684:                break;
    #####:  685:            case 'd':
    #####:  686:                datagram_path = strdup(optarg);
    #####:  687:                break;
        2:  688:            case 'f':
        2:  689:                save_file_path = strdup(optarg);
        2:  690:                break;
    #####:  691:            case 'c':
    #####:  692:                carbon = strtoull(optarg, NULL, 10);
    #####:  693:                if (carbon > MAX_ATOMS) {
    #####:  694:                    fprintf(stderr, "Error: Initial carbon atoms too large (max: %llu)\n", MAX_ATOMS);
    #####:  695:                    exit(EXIT_FAILURE);
        -:  696:                }
    #####:  697:                break;
    #####:  698:            case 'o':
    #####:  699:                oxygen = strtoull(optarg, NULL, 10);
    #####:  700:                if (oxygen > MAX_ATOMS) {
    #####:  701:                    fprintf(stderr, "Error: Initial oxygen atoms too large (max: %llu)\n", MAX_ATOMS);
    #####:  702:                    exit(EXIT_FAILURE);
        -:  703:                }
    #####:  704:                break;
    #####:  705:            case 'H':
    #####:  706:                hydrogen = strtoull(optarg, NULL, 10);
    #####:  707:                if (hydrogen > MAX_ATOMS) {
    #####:  708:                    fprintf(stderr, "Error: Initial hydrogen atoms too large (max: %llu)\n", MAX_ATOMS);
    #####:  709:                    exit(EXIT_FAILURE);
        -:  710:                }
    #####:  711:                break;
    #####:  712:            case 't':
    #####:  713:                timeout_seconds = atoi(optarg);
    #####:  714:                if (timeout_seconds <= 0) {
    #####:  715:                    fprintf(stderr, "Error: Invalid timeout: %s\n", optarg);
    #####:  716:                    exit(EXIT_FAILURE);
        -:  717:                }
    #####:  718:                break;
        1:  719:            case '?':
        -:  720:            default:
        1:  721:                show_usage(argv[0]);
        1:  722:                exit(EXIT_FAILURE);
        -:  723:        }
        -:  724:    }
        -:  725:    
        -:  726:    // Save file is required
        4:  727:    if (!save_file_path) {
        2:  728:        fprintf(stderr, "Error: Save file path is required (-f option)\n");
        2:  729:        show_usage(argv[0]);
        2:  730:        exit(EXIT_FAILURE);
        -:  731:    }
        -:  732:    
        -:  733:    // Check that we have either network ports or UDS paths
        2:  734:    int has_network = (tcp_port != -1) || (udp_port != -1);
       2*:  735:    int has_uds = (stream_path != NULL) || (datagram_path != NULL);
        -:  736:    
        2:  737:    if (!has_network && !has_uds) {
        1:  738:        fprintf(stderr, "Error: Must specify either network ports (-T/-U) or UDS paths (-s/-d)\n");
        1:  739:        show_usage(argv[0]);
        1:  740:        exit(EXIT_FAILURE);
        -:  741:    }
        -:  742:    
        1:  743:    if (tcp_port != -1 && udp_port != -1 && tcp_port == udp_port) {
        1:  744:        fprintf(stderr, "Error: TCP and UDP ports must be different\n");
        1:  745:        exit(EXIT_FAILURE);
        -:  746:    }
        -:  747:    
        -:  748:    // Initialize inventory file
    #####:  749:    if (init_inventory_file(save_file_path, carbon, oxygen, hydrogen) == -1) {
    #####:  750:        fprintf(stderr, "Error: Failed to initialize inventory file\n");
    #####:  751:        exit(EXIT_FAILURE);
        -:  752:    }
        -:  753:    
        -:  754:    // Setup cleanup on exit
    #####:  755:    atexit(cleanup_inventory);
        -:  756:    
        -:  757:    // Setup timeout if specified
    #####:  758:    if (timeout_seconds > 0) {
    #####:  759:        signal(SIGALRM, timeout_handler);
    #####:  760:        alarm(timeout_seconds);
    #####:  761:        printf("Server will timeout after %d seconds of inactivity\n", timeout_seconds);
        -:  762:    }
        -:  763:    
    #####:  764:    printf("Starting Persistent Warehouse server with:\n");
    #####:  765:    if (tcp_port != -1) printf("TCP port: %d\n", tcp_port);
    #####:  766:    if (udp_port != -1) printf("UDP port: %d\n", udp_port);
    #####:  767:    if (stream_path) printf("UDS stream path: %s\n", stream_path);
    #####:  768:    if (datagram_path) printf("UDS datagram path: %s\n", datagram_path);
    #####:  769:    printf("Save file: %s\n", save_file_path);
    #####:  770:    printf("Current atoms - Carbon: %llu, Oxygen: %llu, Hydrogen: %llu\n", 
    #####:  771:           inventory->carbon, inventory->oxygen, inventory->hydrogen);
        -:  772:    
        -:  773:    // Initialize sockets
    #####:  774:    int tcp_fd = -1, udp_fd = -1, uds_stream_fd = -1, uds_datagram_fd = -1;
    #####:  775:    int new_fd, fdmax = STDIN_FILENO;
        -:  776:    fd_set master_set, read_fds;
        -:  777:    
        -:  778:    // TCP socket
    #####:  779:    if (tcp_port != -1) {
        -:  780:        struct sockaddr_in tcp_addr;
    #####:  781:        tcp_fd = socket(AF_INET, SOCK_STREAM, 0);
    #####:  782:        if (tcp_fd < 0) { perror("TCP socket error"); exit(1); }
        -:  783:        
    #####:  784:        tcp_addr.sin_family = AF_INET;
    #####:  785:        tcp_addr.sin_addr.s_addr = INADDR_ANY;
    #####:  786:        tcp_addr.sin_port = htons(tcp_port);
        -:  787:        
    #####:  788:        if (bind(tcp_fd, (struct sockaddr*)&tcp_addr, sizeof(tcp_addr)) < 0) {
    #####:  789:            perror("TCP bind");
    #####:  790:            exit(1);
        -:  791:        }
    #####:  792:        if (listen(tcp_fd, MAX_CLIENTS) < 0) {
    #####:  793:            perror("TCP listen");
    #####:  794:            exit(1);
        -:  795:        }
    #####:  796:        if (tcp_fd > fdmax) fdmax = tcp_fd;
        -:  797:    }
        -:  798:    
        -:  799:    // UDP socket
    #####:  800:    if (udp_port != -1) {
        -:  801:        struct sockaddr_in udp_addr;
    #####:  802:        udp_fd = socket(AF_INET, SOCK_DGRAM, 0);
    #####:  803:        if (udp_fd < 0) { perror("UDP socket error"); exit(1); }
        -:  804:        
    #####:  805:        udp_addr.sin_family = AF_INET;
    #####:  806:        udp_addr.sin_addr.s_addr = INADDR_ANY;
    #####:  807:        udp_addr.sin_port = htons(udp_port);
        -:  808:        
    #####:  809:        if (bind(udp_fd, (struct sockaddr*)&udp_addr, sizeof(udp_addr)) < 0) {
    #####:  810:            perror("UDP bind");
    #####:  811:            exit(1);
        -:  812:        }
    #####:  813:        if (udp_fd > fdmax) fdmax = udp_fd;
        -:  814:    }
        -:  815:    
        -:  816:    // UDS stream socket
    #####:  817:    if (stream_path) {
        -:  818:        struct sockaddr_un stream_addr;
    #####:  819:        unlink(stream_path);
        -:  820:        
    #####:  821:        uds_stream_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    #####:  822:        if (uds_stream_fd < 0) { perror("UDS stream socket error"); exit(1); }
        -:  823:        
    #####:  824:        memset(&stream_addr, 0, sizeof(stream_addr));
    #####:  825:        stream_addr.sun_family = AF_UNIX;
    #####:  826:        strncpy(stream_addr.sun_path, stream_path, sizeof(stream_addr.sun_path) - 1);
        -:  827:        
    #####:  828:        if (bind(uds_stream_fd, (struct sockaddr*)&stream_addr, sizeof(stream_addr)) < 0) {
    #####:  829:            perror("UDS stream bind");
    #####:  830:            exit(1);
        -:  831:        }
    #####:  832:        if (listen(uds_stream_fd, MAX_CLIENTS) < 0) {
    #####:  833:            perror("UDS stream listen");
    #####:  834:            exit(1);
        -:  835:        }
    #####:  836:        if (uds_stream_fd > fdmax) fdmax = uds_stream_fd;
        -:  837:    }
        -:  838:    
        -:  839:    // UDS datagram socket
    #####:  840:    if (datagram_path) {
        -:  841:        struct sockaddr_un datagram_addr;
    #####:  842:        unlink(datagram_path);
        -:  843:        
    #####:  844:        uds_datagram_fd = socket(AF_UNIX, SOCK_DGRAM, 0);
    #####:  845:        if (uds_datagram_fd < 0) { perror("UDS datagram socket error"); exit(1); }
        -:  846:        
    #####:  847:        memset(&datagram_addr, 0, sizeof(datagram_addr));
    #####:  848:        datagram_addr.sun_family = AF_UNIX;
    #####:  849:        strncpy(datagram_addr.sun_path, datagram_path, sizeof(datagram_addr.sun_path) - 1);
        -:  850:        
    #####:  851:        if (bind(uds_datagram_fd, (struct sockaddr*)&datagram_addr, sizeof(datagram_addr)) < 0) {
    #####:  852:            perror("UDS datagram bind");
    #####:  853:            exit(1);
        -:  854:        }
    #####:  855:        if (uds_datagram_fd > fdmax) fdmax = uds_datagram_fd;
        -:  856:    }
        -:  857:    
        -:  858:    // Setup select
    #####:  859:    FD_ZERO(&master_set);
    #####:  860:    if (tcp_fd != -1) FD_SET(tcp_fd, &master_set);
    #####:  861:    if (udp_fd != -1) FD_SET(udp_fd, &master_set);
    #####:  862:    if (uds_stream_fd != -1) FD_SET(uds_stream_fd, &master_set);
    #####:  863:    if (uds_datagram_fd != -1) FD_SET(uds_datagram_fd, &master_set);
    #####:  864:    FD_SET(STDIN_FILENO, &master_set);
        -:  865:    
    #####:  866:    printf("Server ready. Type 'shutdown' to stop.\n");
    #####:  867:    printf("Available drink commands: GEN SOFT DRINK, GEN VODKA, GEN CHAMPAGNE\n");
        -:  868:    
        -:  869:    // Main loop
        -:  870:    while (1) {
        -:  871:        // Check timeout
    #####:  872:        if (timeout_occurred) {
    #####:  873:            printf("Timeout occurred. Server shutting down.\n");
    #####:  874:            break;
        -:  875:        }
        -:  876:        
    #####:  877:        read_fds = master_set;
    #####:  878:        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1) {
    #####:  879:            if (timeout_occurred) break;
    #####:  880:            perror("select");
    #####:  881:            exit(1);
        -:  882:        }
        -:  883:        
        -:  884:        // Reset alarm on activity
    #####:  885:        if (timeout_seconds > 0) {
    #####:  886:            alarm(timeout_seconds);
        -:  887:        }
        -:  888:        
    #####:  889:        for (int i = 0; i <= fdmax; i++) {
    #####:  890:            if (FD_ISSET(i, &read_fds)) {
    #####:  891:                if (i == tcp_fd || i == uds_stream_fd) {
        -:  892:                    // New stream connection
    #####:  893:                    if (i == tcp_fd) {
        -:  894:                        struct sockaddr_in client_addr;
    #####:  895:                        socklen_t addrlen = sizeof(client_addr);
    #####:  896:                        new_fd = accept(tcp_fd, (struct sockaddr*)&client_addr, &addrlen);
    #####:  897:                        if (new_fd == -1) {
    #####:  898:                            perror("TCP accept");
        -:  899:                        } else {
    #####:  900:                            FD_SET(new_fd, &master_set);
    #####:  901:                            if (new_fd > fdmax) fdmax = new_fd;
    #####:  902:                            printf("New TCP connection from %s on socket %d\n",
        -:  903:                                   inet_ntoa(client_addr.sin_addr), new_fd);
        -:  904:                            
        -:  905:                            // Send welcome message
        -:  906:                            char welcome_msg[BUFFER_SIZE];
    #####:  907:                            snprintf(welcome_msg, sizeof(welcome_msg), 
        -:  908:                                    "Connected to Persistent Warehouse Server (TCP). Current inventory: C=%llu, O=%llu, H=%llu\n", 
    #####:  909:                                    inventory->carbon, inventory->oxygen, inventory->hydrogen);
    #####:  910:                            send(new_fd, welcome_msg, strlen(welcome_msg), 0);
        -:  911:                        }
        -:  912:                    } else {
        -:  913:                        struct sockaddr_un client_addr;
    #####:  914:                        socklen_t addrlen = sizeof(client_addr);
    #####:  915:                        new_fd = accept(uds_stream_fd, (struct sockaddr*)&client_addr, &addrlen);
    #####:  916:                        if (new_fd == -1) {
    #####:  917:                            perror("UDS stream accept");
        -:  918:                        } else {
    #####:  919:                            FD_SET(new_fd, &master_set);
    #####:  920:                            if (new_fd > fdmax) fdmax = new_fd;
    #####:  921:                            printf("New UDS stream connection on socket %d\n", new_fd);
        -:  922:                            
        -:  923:                            // Send welcome message
        -:  924:                            char welcome_msg[BUFFER_SIZE];
    #####:  925:                            snprintf(welcome_msg, sizeof(welcome_msg), 
        -:  926:                                    "Connected to Persistent Warehouse Server (UDS). Current inventory: C=%llu, O=%llu, H=%llu\n", 
    #####:  927:                                    inventory->carbon, inventory->oxygen, inventory->hydrogen);
    #####:  928:                            send(new_fd, welcome_msg, strlen(welcome_msg), 0);
        -:  929:                        }
        -:  930:                    }
    #####:  931:                } else if (i == udp_fd || i == uds_datagram_fd) {
        -:  932:                    // Handle datagram request
        -:  933:                    char buffer[BUFFER_SIZE];
        -:  934:                    
    #####:  935:                    if (i == udp_fd) {
        -:  936:                        struct sockaddr_in client_addr;
    #####:  937:                        socklen_t addrlen = sizeof(client_addr);
    #####:  938:                        int nbytes = recvfrom(udp_fd, buffer, sizeof(buffer) - 1, 0,
        -:  939:                                               (struct sockaddr*)&client_addr, &addrlen);
    #####:  940:                        if (nbytes < 0) {
    #####:  941:                            perror("UDP recvfrom");
    #####:  942:                            continue;
        -:  943:                        }
    #####:  944:                        buffer[nbytes] = '\0';
    #####:  945:                        handle_molecule_request(buffer, udp_fd, (struct sockaddr*)&client_addr, addrlen);
        -:  946:                    } else {
        -:  947:                        struct sockaddr_un client_addr;
    #####:  948:                        socklen_t addrlen = sizeof(client_addr);
    #####:  949:                        int nbytes = recvfrom(uds_datagram_fd, buffer, sizeof(buffer) - 1, 0,
        -:  950:                                               (struct sockaddr*)&client_addr, &addrlen);
    #####:  951:                        if (nbytes < 0) {
    #####:  952:                            perror("UDS datagram recvfrom");
    #####:  953:                            continue;
        -:  954:                        }
    #####:  955:                        buffer[nbytes] = '\0';
    #####:  956:                        handle_molecule_request(buffer, uds_datagram_fd, (struct sockaddr*)&client_addr, addrlen);
        -:  957:                    }
    #####:  958:                } else if (i == STDIN_FILENO) {
        -:  959:                    // Handle admin input
        -:  960:                    char input[BUFFER_SIZE];
    #####:  961:                    if (fgets(input, sizeof(input), stdin)) {
    #####:  962:                        if (strncmp(input, "shutdown", 8) == 0) {
    #####:  963:                            printf("Shutdown command received. Notifying clients...\n");
    #####:  964:                            for (int j = 0; j <= fdmax; j++) {
    #####:  965:                                if (FD_ISSET(j, &master_set) && j != tcp_fd && j != udp_fd && 
    #####:  966:                                    j != uds_stream_fd && j != uds_datagram_fd && j != STDIN_FILENO) {
    #####:  967:                                    send(j, "Server shutting down.\n", strlen("Server shutting down.\n"), 0);
    #####:  968:                                    close(j);
        -:  969:                                }
        -:  970:                            }
    #####:  971:                            break;
        -:  972:                        } else {
    #####:  973:                            process_drink_command(input);
        -:  974:                        }
        -:  975:                    }
        -:  976:                } else {
        -:  977:                    // Handle stream client data
        -:  978:                    char buffer[BUFFER_SIZE];
        -:  979:                    char response[BUFFER_SIZE];
    #####:  980:                    int nbytes = recv(i, buffer, sizeof(buffer) - 1, 0);
    #####:  981:                    if (nbytes <= 0) {
    #####:  982:                        if (nbytes == 0) printf("Socket %d hung up\n", i);
    #####:  983:                        else perror("recv");
    #####:  984:                        close(i);
    #####:  985:                        FD_CLR(i, &master_set);
        -:  986:                    } else {
    #####:  987:                        buffer[nbytes] = '\0';
    #####:  988:                        process_command(buffer, response, sizeof(response));
    #####:  989:                        send(i, response, strlen(response), 0);
        -:  990:                    }
        -:  991:                }
        -:  992:            }
        -:  993:        }
        -:  994:    }
        -:  995:    
        -:  996:    // Cleanup
    #####:  997:    if (tcp_fd != -1) close(tcp_fd);
    #####:  998:    if (udp_fd != -1) close(udp_fd);
    #####:  999:    if (uds_stream_fd != -1) {
    #####: 1000:        close(uds_stream_fd);
    #####: 1001:        if (stream_path) unlink(stream_path);
        -: 1002:    }
    #####: 1003:    if (uds_datagram_fd != -1) {
    #####: 1004:        close(uds_datagram_fd);
    #####: 1005:        if (datagram_path) unlink(datagram_path);
        -: 1006:    }
        -: 1007:    
    #####: 1008:    if (stream_path) free(stream_path);
    #####: 1009:    if (datagram_path) free(datagram_path);
    #####: 1010:    if (save_file_path) free(save_file_path);
        -: 1011:    
    #####: 1012:    printf("Server terminated. Inventory saved.\n");
    #####: 1013:    return 0;
        -: 1014:}
